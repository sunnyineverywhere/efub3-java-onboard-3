# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">

- Plain Old Java Object. 오래된 방식의 간단한 자바 오브젝트라는 말.
- 특정 기술에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말하는 것.
- POJO를 지향해야 하는 이유: 특정 기술과 환경에 종속되어 의존하게 된 자바 코드는 가독성이 떨어져 유지보수에 어려움이 생기고, 특정 기술에 의존하게 되어 확장성이 낮아지므로.
</div>
</details>
<br>

<details>
<summary>제너릭이 무엇인가요? 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">

1. 제너릭이란?
- 데이터 형식에 의존하지 않고, 하나의 값이 여러 다른 데이터 타입들을 가질 수 있도록 하는 방법
- 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것
- 어떤 자료구조를 만들어 배포하려고 할 때, 다양한 타입을 지원하고 싶다면 String에 대한 클래스, Integer에 대한 클래스 등 하나하나 타입에 따라 만들지 않음. 이때, 제네릭이라는 것을 사용하는 것. 
2. 제너릭을 사용하는 이유
- 컴파일 시 강한 타입 체크를 할 수 있음: 컴파일 단계에서 에러를 다 도출해내기 때문에 실행 중에 일어나는 에러(RuntimeException)를 방지할 수 있음.
- 타입 변환을 제거함: 제네릭을 사용하지 않는 경우, 불필요한 타입 변환이 필요하게 되는데, 이는 프로그램 성능에 좋지 않은 영향을 미침.
- 재사용성이 좋아짐: 오버로딩을 할 필요없이 코드라인수를 줄일 수 있고 재사용성을 높일s 수 있음
</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">

1. static 변수 선언부
- 클래스가 로드 될 때
- 변수가 제일 먼저 초기화 됨
2. 필드 변수 선언부
- 객체 생성 될 때
- 생성자 block 보다 앞서 초기화 함
3. 생성자 block
- 객체 생성 될 때
- 필드 변수 중 final 변수의 가시화는 (다른 스레드에 공개하는 시점은) 생성자 block이 끝난 다음.
4. 초기화 시점
- 클래스 변수: 클래스가 처음 로딩될 때 단 한 번
- 인스턴스 변수: 인스턴스가 생성될 때마다 각 인스턴스 별로 초기화
5. 초기화 순서
- 클래스 변수: 기본값 ➡️ 명시적초기화 ➡️ 클래스 초기화 블럭
- 인스턴스 변수: 기본값 ➡️ 명시적초기화 ➡️ 인스턴스 초기화 블럭 ➡️ 생성 
</div>
</details>
<br>

<details>
<summary>직렬화란 무엇인가요?</summary>
<div markdown="1">

- CS에서의 직렬화: 현재 데이터(structure, object)의 상태를 영속적으로 저장하거나 다른 환경으로 전달(네트워크 통신 등)하기 위해 어떠한 정해진 포맷으로 변환하는 과정
- JAVA에서의 직렬화
  - 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)
  - 시스템 적으로는 JVM(Java Virtual Machine)의 메모리에 상주(heap 또는 stack) 되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태
- 자바에서는 직렬화 시 데이터(object)를 바이트(byte) 스트림 형태로 변환함.
- 직렬화 방법: 자바 직렬화를 하기 위해서 type이 `primitive type`이거나 `java.io.Serializable` 인터페이스를 상속 받아야 합
</div>
</details>
<br>

<details>
<summary>[예습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">

1. SOLID란?
- 객체 지향 설계 5대 원칙
- 원칙
  - SRP (Single Responsibility Principle) 단일 책임 원칙
  - OCP (Open Closed Principle) 개방 폐쇄 원칙
  - LSP (Liskov Substitution Principle) 리스코프 치환 원칙
  - ISP (Interface Segregation Principle) 인터페이스 분리 원칙
  - DIP (Dependency Inversion Principle) 의존 역전 원칙
2. SRP(단일 책임 원칙)
- 해당 모듈이 여러 대상 또는 액터들에 대해 책임을 가져서는 안되고, 오직 하나의 액터에 대해서만 책임을 져야 한다.
- 모듈이 변경되는 이유가 한가지여야 함.
- 단일 책임 원칙을 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해짐
3. OCP(개방-폐쇄 원칙)
- 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다.
    - `확장에 대해 열려 있다` : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있음을 의미
    - `수정에 대해 닫혀 있다` : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있어야 함을 의미
-  개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 함.
   <br>➕`추상화`란, 핵심적인 부분만 남기고, 불필요한 부분은 제거함으로써 복잡한 것을 간단히 하는 것.
4. LSP(리스코프 치환 원칙)
- 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것.
- 즉, 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도, 차이점을 인식하지 못한 채 상위 타입의 서브 클래스를 사용할 수 있어야 한다.
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 함.
5. DIP(의존 역전 원칙)
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 되며, 저수준 모듈이 고수준 모듈에 의존해야 한다.
    - `고수준 모듈` : 입력과 출력으로부터 먼(비즈니스와 관련된) 추상화된 모듈
    - `저수준 모듈` : 입력과 출력으로부터 가까운(HTTP, 데이터베이스, 캐시 등과 관련된) 구현 모듈
- 즉, 비즈니스와 관련된 부분이 세부 사항에는 의존하지 않는 설계 원칙을 의미함.
- 의존 역전 원칙은 개방 폐쇄 원칙과 밀접한 관련이 있으며, 의존 역전 원칙이 위배되면 개방 폐쇄 원칙 역시 위배될 가능성이 높음.
6. ISP(인터페이스 분리 원칙)
- 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공해야 한다.
- 모든 클라이언트가 자신의 관심에 맞는 퍼블릭 인터페이스(외부에서 접근 가능한 메세지)만을 접근하여 불필요한 간섭을 최소화할 수 있음.
- 기존 클라이언트에 영향을 주지 않은 채로 유연하게 객체의 기능을 확장하거나 수정할 수 있음.
</div>
</details>
<br>

<details>
<summary>[예습] DI는 무엇일까요?</summary>
<div markdown="1">

- 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴
- 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않도록 하고 런타임 시에 관계를 동적으로 주입
- 주입 방법: 생성자 주입, 필드 주입, 수정자 주입 등
- 의존성 주입(Dependency Injection)이 필요한 이유: 아래의 두 가지 경우에 대한 해결책이 될 수 있음
  - 두 객체 간의 관계라는 관심사의 분리
  - 두 객체 간의 결합도를 낮춤
  - 객체의 유연성을 높임
  - 테스트 작성을 용이하게 함
- 하지만 의존 관계를 주입할 객체를 계속해서 생성하고 소멸한다면, 아무리 GC가 성능이 좋아졌다고 하더라도 부담이 될 수 있음
➡️ Spring에서는 기본적으로 Bean들을 싱글톤(Singleton)으로 관리함.

</div>
</details>
<br>